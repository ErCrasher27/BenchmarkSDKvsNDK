<resources>
    <!-- App -->
    <string name="app_name">Benchmark SDK vs NDK</string>

    <!-- Home screen -->
    <string name="home_title">SDK vs NDK: when does native make sense?</string>
    <string name="home_start_benchmark">Start benchmark</string>
    <string name="home_swipe_hint">Swipe to read more →</string>

    <!-- Teaching cards -->
    <!-- TEACHING-CARD-EXTENSION-POINT -->
    <string name="teaching_shocking_truth_title">The "1 Million" Myth</string>
    <string name="teaching_shocking_truth_content">
        • Even with 1M+ elements, SDK (Kotlin) can beat NDK.\n
        • Why? Moving data across JNI isn\'t free. Copying a massive array to C++ takes time.\n
        • If the math isn\'t super heavy, the copy cost > the speedup.
    </string>

    <string name="teaching_binary_search_title">O(log n) vs JNI Overhead</string>
    <string name="teaching_binary_search_content">
        • Binary Search is too fast (microseconds).\n
        • The JNI "tax" to switch context costs more than the search itself.\n
        • Result: 0ms vs 0ms, but SDK is technically cleaner and safer.
    </string>

    <string name="teaching_when_native_fails_title">When Native Fails (Real Data)</string>
    <string name="teaching_when_native_fails_content">
        • Memory-bound tasks (sorting, searching) often lose in NDK.\n
        • The Android Runtime (ART) optimizes Kotlin loops incredibly well.\n
        • Use NDK for computation (math), not just moving data.
    </string>

    <string name="teaching_what_wins_title">So... What wins?</string>
    <string name="teaching_what_wins_content">
        • You need HIGH complexity (O(n³) or more) with LOW data transfer.\n
        • Example: Image processing, crypto, physics simulations.\n
        • Don\'t use NDK just to sort a list. It\'s a trap.
    </string>

    <!-- Benchmark screen -->
    <string name="benchmark_title">Benchmark SDK vs NDK</string>
    <string name="benchmark_run_button">Run benchmark</string>
    <string name="benchmark_last_run">Last result</string>
    <string name="benchmark_sdk_time">SDK: %1$d ms</string>
    <string name="benchmark_ndk_time">NDK: %1$d ms</string>
    <string name="benchmark_speedup">Speedup SDK/NDK: %1$s×</string>
    <string name="benchmark_button_view_stats">View statistics</string>
    <string name="benchmark_stats_require_runs">
        To view statistics, run at least 10 benchmarks with the same algorithm and input size.
    </string>

    <!-- Input sizes -->
    <!-- BENCHMARK-EXTENSION-POINT (optional) -->
    <string name="benchmark_input_1k">1K elements</string>
    <string name="benchmark_input_10k">10K elements</string>
    <string name="benchmark_input_100k">100K elements</string>
    <string name="benchmark_input_1kk">1kK elements</string>

    <!-- Algorithms -->
    <!-- BENCHMARK-EXTENSION-POINT -->
    <string name="benchmark_algorithm_merge_sort">Merge sort</string>
    <string name="benchmark_algorithm_binary_search">Binary search</string>

    <!-- Statistics screen -->
    <string name="statistics_title">Benchmark results</string>
    <string name="statistics_run_config_label">Algorithm, input size, and runs</string>
    <string name="statistics_algorithm">Algorithm: %s</string>
    <string name="statistics_input_size">Input size: %d elements</string>
    <string name="statistics_iterations">Runs: %d</string>

    <string name="statistics_speedup_title">Speedup</string>
    <string name="statistics_avg_times_title">Average times</string>
    <string name="statistics_sdk_average">SDK: %.2f ms</string>
    <string name="statistics_ndk_average">NDK: %.2f ms</string>

    <string name="statistics_sdk_wins">SDK wins</string>
    <string name="statistics_ndk_wins">NDK wins</string>

    <string name="statistics_button_run_again">Run another benchmark</string>
    <string name="statistics_button_back_home">Back to home</string>
</resources>